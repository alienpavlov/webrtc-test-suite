{"version":3,"sources":["checks/peerConnection.js","checks/mediaCapture.js","checks/internet.js","index.js"],"names":["checkPeerConnection","rtcConfig","verbose","callback","Promise","resolve","reject","rtc1","RTCPeerConnection","rtc2","dc","createDataChannel","_ts","Date","now","_err","err","_log","console","log","arguments","addEventListener","ice","candidate","addIceCandidate","evt","channel","msg","data","toString","_rcvTS","close","Error","send","createOffer","then","offer","setLocalDescription","setRemoteDescription","createAnswer","answer","catch","e","checkMediaCapture","constraints","video","audio","navigator","mediaDevices","getUserMedia","stream","active","tracks","getTracks","audioTrack","videoTrack","functional","every","call","_track","kind","readyState","forEach","stop","checkInternetSpeed","checkerFile","startTime","fetch","resp","blob","bl","endTime","timeDiff","mbps","size","toFixed","_RTCTest","window"],"mappings":"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","file":"index.js","sourceRoot":"..","sourcesContent":["/**\n * Created By Anam Ahmed (https://anam.co)\n * Test the browser's capability to establish RTCPeerConnection with supplied RTC Configuration\n * How to use: probeRTC(RTCParam,false, callback) // will call callback function with true or false.\n * If you don't supply the callback function it will return a Promise.\n * The promise will resolve (with total time required for the whole round trip ,in ms) or reject (with error) based on the result.\n * Setting verbose = true will print logs in console\n * @param {RTCConfiguration} rtcConfig\n * @param {Boolean} verbose\n * @param {Function} callback [optional]\n * @return {Promise}\n */\nfunction checkPeerConnection(rtcConfig = {}, verbose = false, callback){\n    return new Promise((resolve,reject)=>{\n        let rtc1 = new RTCPeerConnection();\n        let rtc2 = new RTCPeerConnection();\n        let dc   = rtc1.createDataChannel(\"sender\");\n        let _ts  = Date.now();\n        function _err(err){\n            if(callback) return callback(false);\n            return reject(err);\n        }\n        function _log(){\n            if(!verbose) return false;\n            console.log(...arguments);\n        }\n        rtc1.addEventListener(\"icecandidate\",ice=>{\n            if(!ice.candidate) return false;\n            _log(\"🚖  First Peer Generated Candidate:\",ice.candidate);\n            rtc2.addIceCandidate(ice.candidate);\n        });\n        rtc2.addEventListener(\"icecandidate\",ice=>{\n            if(!ice.candidate) return false;\n            _log(\"🚖  Second Peer Generated Candidate:\",ice.candidate);\n            rtc1.addIceCandidate(ice.candidate);\n        });\n        rtc2.addEventListener(\"datachannel\",evt=>{\n            evt.channel.addEventListener(\"message\",(msg)=>{\n                _log(\"✉️  Message Transmission successful\");\n                if(msg.data === _ts.toString()){\n                    if(callback) return callback(true);\n                    let _rcvTS = Date.now();\n                    rtc1.close();\n                    rtc2.close();\n                    return resolve(_rcvTS - _ts);\n                }\n                _err(new Error(\"message integrity failure\"));\n            });\n        });\n        dc.addEventListener(\"open\",()=>dc.send(_ts.toString()));\n        rtc1.createOffer()\n            .then(offer=>{\n                _log(\"🍎  Created RTC Offer\");\n                rtc1.setLocalDescription(offer)\n                    .then(()=>rtc2.setRemoteDescription(offer))\n                    .then(()=>rtc2.createAnswer()\n                        .then(answer=>{\n                            _log(\"🍏  Created RTC Answer\");\n                            rtc2.setLocalDescription(answer)\n                                .then(()=>rtc1.setRemoteDescription(answer))\n                                .catch(e=>_err(e));\n                        }).catch(e=>_err(e)));\n            }).catch(e=>_err(e));\n    });\n}\n\nexport default checkPeerConnection;\n","/**\n * Tests media capture by calling getUserMedia and analyzing the media stream\n * Created by Anam Ahmed (https://anam.co)\n * @param {MediaStreamConstraints} constraints\n * @param {Boolean} verbose\n * @param {Function} callback\n */\nfunction checkMediaCapture(constraints = {video: true, audio: true},verbose = false, callback){\n    return new Promise((resolve,reject)=>{\n        function _err(err){\n            if(callback) return callback(false);\n            return reject(err);\n        }\n        function _log(){\n            if(!verbose) return false;\n            console.log(...arguments);\n        }\n        navigator.mediaDevices.getUserMedia(constraints)\n            .then(stream=>{\n                _log(\"🏞  Got Media stream\");\n                if(stream.active){\n                    let tracks     = stream.getTracks();\n                    var audioTrack = false; // check by default\n                    var videoTrack = false; // check by default\n                    let functional = [].every.call(tracks,_track=>{\n                        if(_track.kind === \"audio\") audioTrack = true;\n                        if(_track.kind === \"video\") videoTrack = true;\n                        return (_track.readyState === \"live\");\n                    });\n                    tracks.forEach(_track=>_track.stop());\n                    if(!functional) return _err(new Error(\"All requested tracks are not active\"));\n                    if(constraints.video && !videoTrack) return _err(new Error(\"Video Track not found\"));\n                    if(constraints.audio && !audioTrack) return _err(new Error(\"Audio Track not found\"));\n                    return resolve(true);\n                }\n            })\n            .catch(e=>{\n                _log(\"🛑  Failed at getting media stream\");\n                _err(e);\n            })\n    })\n}\n\nexport default checkMediaCapture;","/**\n * Test Internet download speed\n * @param {checkFile} String, a file on the internet, that can be downloaded via AJAX (has access-control-allow-origin header)\n * @param {verbose} Boolean, prints out logs\n * @param {callback} Function, gets called once the function finishes or fails\n * @returns Promise\n */\nfunction checkInternetSpeed(checkerFile, verbose = false, callback){\n    return new Promise((resolve,reject)=>{\n        if(!checkerFile) reject(new Error(\"Please provide a filename to download and check internet\"));\n        function _log(){\n            if(!verbose) return false;\n            console.log(...arguments);\n        }\n        function _err(err){\n            if(callback) return callback(false);\n            return reject(err);\n        }\n        let startTime = Date.now();\n        _log(`🧲  Fetching the test file`);\n        fetch(`${checkerFile}?rtccheckertimestamp_noconflict=${startTime}`)\n            .then(resp=>resp.blob())\n            .then(bl=>{\n                _log(`😇  Test file fetched successfully`);\n                let endTime  = Date.now();\n                let timeDiff = (endTime - startTime)/1000; //convert millesecond diff to seconds\n                let fileSize = bl.size * 8; // bits\n                let bps      = fileSize / timeDiff;\n                let mbps     = (bps / 1048576).toFixed(2); // 1024*1024\n                _log(`🌎  Internet speed observed during fetch: ${mbps} Mbps`);\n                if(callback) return callback(mbps);\n                return resolve(mbps);\n            })\n            .catch(_err);\n    })\n}\n\nexport default checkInternetSpeed;","import checkPeerConnection from \"./checks/peerConnection\";\nimport checkMediaCapture from \"./checks/mediaCapture\";\nimport checkInternetSpeed from \"./checks/internet\";\nlet _RTCTest = {\n    checkPeerConnection,\n    checkMediaCapture,\n    checkInternetSpeed\n}\nif(typeof window !== \"undefined\") window._RTCTest = _RTCTest;\n\nexport default _RTCTest;"]}